# -*- coding: utf-8 -*-

# ZC_SEQ_DET_TOFO_DNN.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
# https://colab.research.google.com/drive/1FmIBaF092GfBLGzCZEQ0ojsbr3vBq3Qq

# DNN MODEL FOR DETECTION OF SUPERIMPOSED ZADOFF-CHU SEQUENCES WITH TIMING AND FREQUENCY OFFSET

# * Objective : To build a deep neural network model which takes superimposed ZC sequences and gives out the sequence number(root) of superimposed ZC sequences.

# THIS IS A MULTI LABEL CLASSIFICATION PROBLEM
# Multi-label classification involves predicting zero or more class labels.

# Unlike normal classification tasks where class labels are mutually exclusive, multi-label classification requires predicting multiple mutually non-exclusive classes or “labels.”

# [Reference for tutorial on multilabel classification](https://machinelearningmastery.com/multi-label-classification-with-deep-learning/)

#%% IMPORTS

# Imports
import scipy
import scipy.io   as sio
import numpy      as np
import pandas     as pd
import tensorflow as tf
import tensorflow.keras.backend as kb
from sklearn.model_selection import train_test_split
from sklearn.utils           import shuffle
from sklearn.preprocessing   import OneHotEncoder 
from sklearn.preprocessing   import Binarizer
import matplotlib.pyplot as plt
# !pip install -U tensorflow-addons
# import tensorflow_addons as tfa
# import time
# import sklearn.metrics
# from sklearn.model_selection import KFold
# from sklearn.model_selection import cross_val_score

# To get reproducable results
# np.random.seed(1998)
# tf.random.set_seed(8)


#%% PARAMETERS


Model_type = 0
# 0 -> DNN
# 1 -> CNN

Train_model  = 1
# 0 -> Use saved model
# 1 -> Train the model
if Train_model != 1:
  Save_model = 0
else:  
  Save_model = 1

Output_analysis   = 1
combine_outputs   = 1
Accuracy_analysis = 1
Extra_results_analysis = 0
Overall_accuracy_analysis = 1

Save_results      = 1
Save_accuracy     = 1
Save_extra_results  = 1
Save_accuracy_overall = 1

Create_results_sheets = 1
Create_accuracy_sheets = 1
Create_extra_results_sheets = 1
Create_overall_accuracy_sheets = 1

if Create_results_sheets:
  results_awgn_TOFO = pd.DataFrame()
  results_awgn_TOFO["SNR (dB)"] = np.arange(0,21,2)
  results_ray_TOFO  = pd.DataFrame()
  results_ray_TOFO["SNR (dB)"] = np.arange(0,21,2)
  results_epa_TOFO  = pd.DataFrame()
  results_epa_TOFO["SNR (dB)"] = np.arange(0,21,2)

if Create_accuracy_sheets:
  accuracy_NU_TOFO = pd.DataFrame()
  accuracy_NU_TOFO["SNR (dB)"] = np.arange(0,21,2)
  accuracy_OU_TOFO = pd.DataFrame()
  accuracy_OU_TOFO["SNR (dB)"] = np.arange(0,21,2)
  accuracy_TU_TOFO = pd.DataFrame()
  accuracy_TU_TOFO["SNR (dB)"] = np.arange(0,21,2)

if Create_extra_results_sheets:
  extra_results_awgn_TOFO = pd.DataFrame()
  extra_results_awgn_TOFO["SNR (dB)"] = np.arange(0,21,2)
  extra_results_ray_TOFO  = pd.DataFrame()
  extra_results_ray_TOFO["SNR (dB)"] = np.arange(0,21,2)
  extra_results_epa_TOFO  = pd.DataFrame()
  extra_results_epa_TOFO["SNR (dB)"] = np.arange(0,21,2)

if Create_overall_accuracy_sheets: 
  accuracy_overall_TOFO = pd.DataFrame()
  accuracy_overall_TOFO["SNR (dB)"] = np.arange(0,21,2)


#%% LOADING DATASET


#===============================================================================
#================= DIFFERENT CHANNEL IMPAIRMENTS ===============================
#===============================================================================
Ch_list      = ["AWGN","RAYLEIGH+TOFO","EPA+TOFO"]
Channel      = 1
Model_number = 1
# Enter paths of datasets generated for different cases
Train_Dataset_path1 = "D:/PK/ZC_SEQ_DET/RAYLEIGH+TOFO/MODEL_{}/DATASET/Train_NU.mat".format(Model_number)

Train_Dataset_path2 = "D:/PK/ZC_SEQ_DET/RAYLEIGH+TOFO/MODEL_{}/DATASET/Train_OU.mat".format(Model_number)
Train_Dataset_path3 = "D:/PK/ZC_SEQ_DET/RAYLEIGH+TOFO/MODEL_{}/DATASET/Train_TU.mat".format(Model_number)

Test_Dataset_path_NU1  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_NU_a1.mat".format(Ch_list[Channel],Model_number)
Test_Dataset_path_NU2  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_NU_a2.mat".format(Ch_list[Channel],Model_number)

Test_Dataset_path_OU1  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_OU_a1.mat".format(Ch_list[Channel],Model_number)
Test_Dataset_path_OU2  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_OU_a2.mat".format(Ch_list[Channel],Model_number)

Test_Dataset_path_TU1  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_TU_a1.mat".format(Ch_list[Channel],Model_number)
Test_Dataset_path_TU2  = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DATASET/Test_TU_a2.mat".format(Ch_list[Channel],Model_number)

# Enter path to store the sequence detection DNN/CNN model and results 
if Model_type == 0:
  Model_path    = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/DNN".format(Ch_list[Channel],Model_number)
if Model_type == 1:  
  Model_path    = "D:/PK/ZC_SEQ_DET/{}/MODEL_{}/CNN".format(Ch_list[Channel],Model_number)
Results_path     = "D:/PK/ZC_SEQ_DET/Results/"


# For loading '.mat' files from matlab we use 'loadmat' from 'scipy.io'
Train_NU       = sio.loadmat(Train_Dataset_path1)['Train_NU']
Train_OU       = sio.loadmat(Train_Dataset_path2)['Train_OU']
Train_TU       = sio.loadmat(Train_Dataset_path3)['Train_TU']
Test_NU_a1_DNN     = sio.loadmat(Test_Dataset_path_NU1)['Test_NU_a1']
Test_NU_a2_DNN     = sio.loadmat(Test_Dataset_path_NU2)['Test_NU_a2']
Test_OU_a1_DNN     = sio.loadmat(Test_Dataset_path_OU1)['Test_OU_a1']
Test_OU_a2_DNN     = sio.loadmat(Test_Dataset_path_OU2)['Test_OU_a2']
Test_TU_a1_DNN     = sio.loadmat(Test_Dataset_path_TU1)['Test_TU_a1']
Test_TU_a2_DNN     = sio.loadmat(Test_Dataset_path_TU2)['Test_TU_a2']



#%% DATA PREPROCESSING/ANALYSIS


# Received complex vector is of 'Preamble_len'
# feature vector -> [Real(received complex vector);Imag(received complex vector)]
# NO USER CASE  : contains data of 1 class
# ONE USER CASE : contains data of 46 classes
# TWO USER CASE : contains data of 1035 classes 

Preamble_len              = 48
Num_features              = Preamble_len*2     # Number of features in input vector
Num_categories            = 46                 # Number of outputs/ number of different ZC sequences
Train_snr                 = 6                  # SNR at which train data is generated
SNRdb_range               = np.arange(0,21,2)  # Different snr values for which test data is generated
Num_SNR_val               = len(SNRdb_range)
Num_classes_NU            = 1                  # number of classes in no user case -> no sequence class
num_test_perSNRval_NU     = 60000              # Number of test data per snr value per class for no user case
Num_classes_OU            = Num_categories     # number of classes in one user case -> 46 different possible classes
num_test_perSNRval_OU     = 1000               # Number of test data per snr value per class for one user case
Num_classes_TU            = 1035               # number of classes in two users case -> 46^C_2 different possible classes
num_test_perSNRval_TU     = 100                # Number of test data per snr value per class for two users case
Testdata_size             = 0.2                # validation data split

# Creating labels
categories     = np.expand_dims(np.arange(1,Num_categories+1),axis=-1)
onehot_encoder = OneHotEncoder(sparse=False)
onehot_encoded = onehot_encoder.fit_transform(categories)

TU_labels = np.zeros((Num_classes_TU,Num_categories))
i = 0
for s1 in range(Num_categories):
  for s2 in range(s1+1,Num_categories):
    TU_labels[i,:] = onehot_encoded[s1,:] + onehot_encoded[s2,:]
    i+=1 

Labels_NU = np.zeros((Train_NU.shape[0],Num_categories)) 
Labels_OU = np.repeat(onehot_encoded,int((Train_OU.shape[0])/Num_classes_OU),axis = 0) 
Labels_TU = np.repeat(TU_labels,int((Train_TU.shape[0])/Num_classes_TU),axis = 0) 

Ltest_NU      = np.zeros((Test_NU_a1_DNN.shape[0],Num_categories)) 
Ltest         = np.repeat(onehot_encoded,num_test_perSNRval_OU,axis = 0)
Ltest_OU      = np.tile(Ltest,(Num_SNR_val,1)) 
Ltest         = np.repeat(TU_labels,num_test_perSNRval_TU,axis = 0)
Ltest_TU      = np.tile(Ltest,(Num_SNR_val,1)) 

# Splitting dataset into train and validation data
Dtrain_NU_DNN, Dval_NU_DNN, Ltrain_NU, Lval_NU = train_test_split(Train_NU,Labels_NU,test_size = Testdata_size, random_state = 98) 
Dtrain_OU_DNN, Dval_OU_DNN, Ltrain_OU, Lval_OU = train_test_split(Train_OU,Labels_OU,test_size = Testdata_size, random_state = 98)
Dtrain_TU_DNN, Dval_TU_DNN, Ltrain_TU, Lval_TU = train_test_split(Train_TU,Labels_TU,test_size = Testdata_size, random_state = 98)

# Final train, validation and test data and labels
Dtrain_DNN = shuffle(np.concatenate((Dtrain_OU_DNN,Dtrain_TU_DNN),axis = 0),random_state = 98)
Dval_DNN   = shuffle(np.concatenate((Dval_OU_DNN, Dval_TU_DNN),axis = 0),random_state = 98)
Dtest_a1_DNN  = shuffle(np.concatenate((Test_NU_a1_DNN, Test_OU_a1_DNN, Test_TU_a1_DNN),axis = 0),random_state = 98) # Test data for antenna 1
Dtest_a2_DNN  = shuffle(np.concatenate((Test_NU_a2_DNN, Test_OU_a2_DNN, Test_TU_a2_DNN),axis = 0),random_state = 98) # Test data for antenna 2

Ltrain = shuffle(np.concatenate((Ltrain_OU,Ltrain_TU),axis = 0),random_state = 98)
Lval   = shuffle(np.concatenate((Lval_OU, Lval_TU),axis = 0),random_state = 98)
Ltest  = shuffle(np.concatenate((Ltest_NU, Ltest_OU, Ltest_TU),axis = 0),random_state = 98)

# # New labels (+1 -> positive class -1-> negative class)
# Ltrain_NU = 2*Ltrain_NU-1
# Ltrain_OU = 2*Ltrain_OU-1
# Ltrain_TU = 2*Ltrain_TU-1
# Lval_NU   = 2*Lval_NU-1
# Lval_OU   = 2*Lval_OU-1
# Lval_TU   = 2*Lval_TU-1
# Ltrain    = 2*Ltrain-1
# Lval      = 2*Lval-1
# Ltest_NU  = 2*Ltest_NU-1
# Ltest_OU  = 2*Ltest_OU-1
# Ltest_TU  = 2*Ltest_TU-1
# Ltest     = 2*Ltest-1


if Model_type == 1:
  # FOR CNN
  Dtrain_OU_CNN = np.zeros((Dtrain_OU_DNN.shape[0],48,2))
  for i in range(Dtrain_OU_DNN.shape[0]):
    Dtrain_OU_CNN[i] = np.reshape(Dtrain_OU_DNN[i,:],(2,48)).T
  Dtrain_OU_CNN = np.expand_dims(Dtrain_OU_CNN,-1)

  Dval_OU_CNN = np.zeros((Dval_OU_DNN.shape[0],48,2))
  for i in range(Dval_OU_DNN.shape[0]):
    Dval_OU_CNN[i] = np.reshape(Dval_OU_DNN[i,:],(2,48)).T
  Dval_OU_CNN = np.expand_dims(Dval_OU_CNN,-1)

  Dtrain_TU_CNN = np.zeros((Dtrain_TU_DNN.shape[0],48,2))
  for i in range(Dtrain_TU_DNN.shape[0]):
    Dtrain_TU_CNN[i] = np.reshape(Dtrain_TU_DNN[i,:],(2,48)).T
  Dtrain_TU_CNN = np.expand_dims(Dtrain_TU_CNN,-1)

  Dval_TU_CNN = np.zeros((Dval_TU_DNN.shape[0],48,2))
  for i in range(Dval_TU_DNN.shape[0]):
    Dval_TU_CNN[i] = np.reshape(Dval_TU_DNN[i,:],(2,48)).T
  Dval_TU_CNN = np.expand_dims(Dval_TU_CNN,-1)

  Dtrain_CNN = np.zeros((Dtrain_DNN.shape[0],48,2))
  for i in range(Dtrain_DNN.shape[0]):
    Dtrain_CNN[i] = np.reshape(Dtrain_DNN[i,:],(2,48)).T
  Dtrain_CNN = np.expand_dims(Dtrain_CNN,-1)

  Dval_CNN = np.zeros((Dval_DNN.shape[0],48,2))
  for i in range(Dval_DNN.shape[0]):
    Dval_CNN[i] = np.reshape(Dval_DNN[i,:],(2,48)).T 
  Dval_CNN = np.expand_dims(Dval_CNN,-1)   

  Test_NU_a1_CNN = np.zeros((Test_NU_a1_DNN.shape[0],48,2))
  for i in range(Test_NU_a1_DNN.shape[0]):
    Test_NU_a1_CNN[i] = np.reshape(Test_NU_a1_DNN[i,:],(2,48)).T 
  Test_NU_a1_CNN = np.expand_dims(Test_NU_a1_CNN,-1) 

  Test_NU_a2_CNN = np.zeros((Test_NU_a2_DNN.shape[0],48,2))
  for i in range(Test_NU_a2_DNN.shape[0]):
    Test_NU_a2_CNN[i] = np.reshape(Test_NU_a2_DNN[i,:],(2,48)).T 
  Test_NU_a2_CNN = np.expand_dims(Test_NU_a2_CNN,-1) 

  Test_OU_a1_CNN = np.zeros((Test_OU_a1_DNN.shape[0],48,2))
  for i in range(Test_OU_a1_DNN.shape[0]):
    Test_OU_a1_CNN[i] = np.reshape(Test_OU_a1_DNN[i,:],(2,48)).T 
  Test_OU_a1_CNN = np.expand_dims(Test_OU_a1_CNN,-1) 

  Test_TU_a2_CNN = np.zeros((Test_TU_a2_DNN.shape[0],48,2))
  for i in range(Test_TU_a2_DNN.shape[0]):
    Test_TU_a2_CNN[i] = np.reshape(Test_TU_a2_DNN[i,:],(2,48)).T 
  Test_TU_a2_CNN = np.expand_dims(Test_TU_a2_CNN,-1)

  Test_TU_a1_CNN = np.zeros((Test_TU_a1_DNN.shape[0],48,2))
  for i in range(Test_TU_a1_DNN.shape[0]):
    Test_TU_a1_CNN[i] = np.reshape(Test_TU_a1_DNN[i,:],(2,48)).T 
  Test_TU_a1_CNN = np.expand_dims(Test_TU_a1_CNN,-1) 

  Test_OU_a2_CNN = np.zeros((Test_OU_a2_DNN.shape[0],48,2))
  for i in range(Test_OU_a2_DNN.shape[0]):
    Test_OU_a2_CNN[i] = np.reshape(Test_OU_a2_DNN[i,:],(2,48)).T 
  Test_OU_a2_CNN = np.expand_dims(Test_OU_a2_CNN,-1)

  Dtest_a1_CNN = np.zeros((Dtest_a1_DNN.shape[0],48,2))
  for i in range(Dtest_a1_DNN.shape[0]):
    Dtest_a1_CNN[i] = np.reshape(Dtest_a1_DNN[i,:],(2,48)).T 
  Dtest_a1_CNN = np.expand_dims(Dtest_a1_CNN,-1)    

  Dtest_a2_CNN = np.zeros((Dtest_a2_DNN.shape[0],48,2))
  for i in range(Dtest_a2_DNN.shape[0]):
    Dtest_a2_CNN[i] = np.reshape(Dtest_a2_DNN[i,:],(2,48)).T  
  Dtest_a2_CNN = np.expand_dims(Dtest_a2_CNN,-1)  
  
  Dtrain_OU = Dtrain_OU_CNN
  Dtrain_TU = Dtrain_TU_CNN
  Dval_OU = Dval_OU_CNN
  Dval_TU = Dval_TU_CNN
  Dtrain    = Dtrain_CNN
  Dval      = Dval_CNN
  Test_NU_a1 = Test_NU_a1_CNN
  Test_NU_a2 = Test_NU_a2_CNN
  Test_OU_a1 = Test_OU_a1_CNN
  Test_OU_a2 = Test_OU_a2_CNN
  Test_TU_a1 = Test_TU_a1_CNN
  Test_TU_a2 = Test_TU_a2_CNN
  Dtest_a1   = Dtest_a1_CNN
  Dtest_a2   = Dtest_a2_CNN

else:
  Dtrain_OU = Dtrain_OU_DNN
  Dtrain_TU = Dtrain_TU_DNN
  Dval_OU = Dval_OU_DNN
  Dval_TU = Dval_TU_DNN
  Dtrain    = Dtrain_DNN
  Dval      = Dval_DNN
  Test_NU_a1 = Test_NU_a1_DNN
  Test_NU_a2 = Test_NU_a2_DNN
  Test_OU_a1 = Test_OU_a1_DNN
  Test_OU_a2 = Test_OU_a2_DNN
  Test_TU_a1 = Test_TU_a1_DNN
  Test_TU_a2 = Test_TU_a2_DNN
  Dtest_a1   = Dtest_a1_DNN
  Dtest_a2   = Dtest_a2_DNN


#%% BUILD DNN MODEL FOR SEQUENCE DETECTION


if Train_model:
  # P_drop = 0.2
  if Model_type == 0:
    ZC_TOFO_model = tf.keras.Sequential(
        [
        tf.keras.layers.InputLayer((Num_features,)),    
        tf.keras.layers.Dense(192, kernel_initializer = tf.keras.initializers.GlorotNormal(),activation ="relu", name = "HiddenLayer1"),
        tf.keras.layers.Dense(192, kernel_initializer = tf.keras.initializers.GlorotNormal(),activation ="relu", name = "HiddenLayer2"), 
        tf.keras.layers.Dense(Num_categories, kernel_initializer = tf.keras.initializers.GlorotNormal(), activation = "sigmoid", name = "OutputLayer")
        ]
    )

    # # # instantiate model
    # ZC_TOFO_model = tf.keras.Sequential()
    
    # # input layer
    # ZC_TOFO_model.add(tf.keras.layers.Input((96,)))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    
    # # hidden layer 1   
    # ZC_TOFO_model.add(tf.keras.layers.Dense(192, kernel_initializer = tf.keras.initializers.GlorotNormal()))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    # ZC_TOFO_model.add(tf.keras.layers.Activation('relu'))
    # ZC_TOFO_model.add(tf.keras.layers.Dropout(P_drop))
    
    # # hidden layer 2   
    # ZC_TOFO_model.add(tf.keras.layers.Dense(96, kernel_initializer = tf.keras.initializers.GlorotNormal()))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    # ZC_TOFO_model.add(tf.keras.layers.Activation('linear'))
    # ZC_TOFO_model.add(tf.keras.layers.Dropout(P_drop))
    
    # # output layer
    # ZC_TOFO_model.add(tf.keras.layers.Dense(Num_categories, kernel_initializer = tf.keras.initializers.GlorotNormal()))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    # ZC_TOFO_model.add(tf.keras.layers.Activation('sigmoid'))
    
    print(ZC_TOFO_model.summary())
    # tf.keras.utils.plot_model(ZC_TOFO_model,show_shapes = True)
 
  
#%% BUILD CNN MODEL FOR SEQUENCE DETECTION


if Train_model:
  if Model_type == 1:
    # ZC_TOFO_model = tf.keras.Sequential(
    #     [
    #     tf.keras.layers.Conv2D(4, (48,1), padding='same', activation="relu",input_shape=(48, 2, 1)),
        
    #     tf.keras.layers.Conv2D(4, (48,2), padding='same', activation="relu"),
    #     tf.keras.layers.Flatten(),
    #     tf.keras.layers.Dropout(0.2),
    #     tf.keras.layers.Dense(96, activation="relu"),
    #     tf.keras.layers.Dense(Num_categories, activation="sigmoid")
    #   ]
    # )
    
    # instantiate model
    ZC_TOFO_model = tf.keras.Sequential()
    
    ZC_TOFO_model.add(tf.keras.layers.Conv2D(16, (1,2), padding='same',input_shape=(48, 2, 1)))
    ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    ZC_TOFO_model.add(tf.keras.layers.Activation('relu'))
    ZC_TOFO_model.add(tf.keras.layers.AveragePooling2D(pool_size=(2,1), strides=1, padding='valid'))
    ZC_TOFO_model.add(tf.keras.layers.Flatten())                
    # output layer
    ZC_TOFO_model.add(tf.keras.layers.Dense(Num_categories, kernel_initializer = tf.keras.initializers.GlorotNormal()))
    ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    ZC_TOFO_model.add(tf.keras.layers.Activation('sigmoid'))
    
    # instantiate model
    # ZC_TOFO_model = tf.keras.Sequential()
    
    # ZC_TOFO_model.add(tf.keras.layers.Conv1D(16, kernel_size = 96, input_shape = (96,1)))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    # ZC_TOFO_model.add(tf.keras.layers.Activation('relu'))
    # ZC_TOFO_model.add(tf.keras.layers.AveragePooling1D(pool_size=48, strides=48, padding='valid'))
    # ZC_TOFO_model.add(tf.keras.layers.Flatten())                  
    
    # # output layer
    # ZC_TOFO_model.add(tf.keras.layers.Dense(Num_categories, kernel_initializer = tf.keras.initializers.GlorotNormal()))
    # ZC_TOFO_model.add(tf.keras.layers.BatchNormalization())
    # ZC_TOFO_model.add(tf.keras.layers.Activation('sigmoid'))

    print(ZC_TOFO_model.summary())
    # tf.keras.utils.plot_model(ZC_TOFO_model,show_shapes = True)


#%% BUILD CUSTOM LOSS FUNCTION

# class_weights_0 = np.array([np.count_nonzero(Ltrain[:,i] == 0)/Ltrain.shape[0] for i in range(Num_categories)])
# class_weights_1 = np.array([np.count_nonzero(Ltrain[:,i] == 1)/Ltrain.shape[0] for i in range(Num_categories)])
# scaling_factor  = class_weights_0/class_weights_1
scaling_factor = 2
eps = 0.000001
def custom_loss(y_true,y_pred):
    wbce = -(scaling_factor * y_true * kb.log(y_pred + eps) + (1 - y_true) * kb.log(1 - y_pred + eps))
    return kb.mean(wbce)


#%% COMPILE AND FIT THE MODEL


# Loss function     : Binary crossentropy
# Optimizer         : Adam
# Evaluation Metrics : Accuracy, Miss detection, False alarm

if Train_model:
  # Hyperparameters
  epochs     = 75
  batch_size = 1024

  # Compile the model 
  adam  = tf.keras.optimizers.Adam(learning_rate=0.001, beta_1=0.95, beta_2=0.999, epsilon=1e-08)

  ZC_TOFO_model.compile(loss = custom_loss, optimizer = adam)
  # Fit the training data to the model
  # checkpoint      = tf.keras.callbacks.ModelCheckpoint(filepath = Results_path, save_best_only = True , monitor='val_categorical_accuracy', save_weights_only = True ,verbose = 1)
  # tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=Tb_logs_path, histogram_freq=1)
  early_stopping  = tf.keras.callbacks.EarlyStopping(monitor = 'val_loss',patience = 5)
  history         = ZC_TOFO_model.fit(Dtrain, Ltrain , validation_data = (Dval, Lval) ,epochs = epochs, batch_size = batch_size, verbose = 1, callbacks = [early_stopping])


#%% ANALYSIS OF OUTPUT FROM THE DNN/CNN

#%%% Combining outputs corresponding to two antennas

if combine_outputs:
    if Output_analysis:
      if Train_model != 1:
        ZC_TOFO_model = tf.keras.models.load_model(Model_path)
    
      Thres_NU_a1  = np.zeros(Num_SNR_val)
      stdv_NU_a1   = np.zeros(Num_SNR_val)
      Thres_NU_a2  = np.zeros(Num_SNR_val)
      stdv_NU_a2   = np.zeros(Num_SNR_val)
      Thres_NU  = np.zeros(Num_SNR_val)
      stdv_NU   = np.zeros(Num_SNR_val)
      
      Thres_OU_a1  = np.zeros(Num_SNR_val)
      stdv_OU_a1   = np.zeros(Num_SNR_val)
      Thres_OU_a2  = np.zeros(Num_SNR_val)
      stdv_OU_a2   = np.zeros(Num_SNR_val)
      Thres_OU  = np.zeros(Num_SNR_val)
      stdv_OU   = np.zeros(Num_SNR_val)
      
      Thres_TU_a1p1  = np.zeros(Num_SNR_val)
      stdv_TU_a1p1   = np.zeros(Num_SNR_val)
      Thres_TU_a1p2  = np.zeros(Num_SNR_val)
      stdv_TU_a1p2   = np.zeros(Num_SNR_val)
      Thres_TU_a2p1  = np.zeros(Num_SNR_val)
      stdv_TU_a2p1   = np.zeros(Num_SNR_val)
      Thres_TU_a2p2  = np.zeros(Num_SNR_val)
      stdv_TU_a2p2   = np.zeros(Num_SNR_val)
      Thres_TU_p1  = np.zeros(Num_SNR_val)
      stdv_TU_p1   = np.zeros(Num_SNR_val)
      Thres_TU_p2  = np.zeros(Num_SNR_val)
      stdv_TU_p2   = np.zeros(Num_SNR_val)
      
    
      #====================================================================================================================================================
      # Estimating threshold for NO USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        n             = num_test_perSNRval_NU * Num_classes_NU
        # ANTENNA 1
        Test_a1       = Test_NU_a1[0 + s * n: (s + 1) * n,:]
        Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
        Lpred_max_a1  = Lpred_a1.max(axis = 1)   
        Thres_NU_a1[s] = np.mean(Lpred_max_a1)
        stdv_NU_a1[s]  = np.std(Lpred_max_a1)
    
        # # ========================== PMR ===========================================
        # Lpred_mean_a1 = np.mean(Lpred_a1,axis = 1)
        # Thres_NU_a1[s] = np.mean(Lpred_max_a1/Lpred_mean_a1)
        # stdv_NU_a1[s]  = np.std(Lpred_max_a1/Lpred_mean_a1)
        
        # ANTENNA 2
        Test_a2       = Test_NU_a2[0 + s * n: (s + 1) * n,:]
        Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
        Lpred_max_a2  = Lpred_a2.max(axis = 1)
        Thres_NU_a2[s]  = np.mean(Lpred_max_a2)
        stdv_NU_a2[s]   = np.std(Lpred_max_a2)
        
        # # ================= Average outputs from two antennas ========================
        # Lpred      = (Lpred_a1 + Lpred_a2)/2
        # Lpred_max  = Lpred.max(axis = 1)
        # Thres_NU[s] = np.mean(Lpred_max)
        # stdv_NU[s]  = np.std(Lpred_max)
    
        # # ========================== PMR ===========================================
        # Lpred_mean_a2 = np.mean(Lpred_a2,axis = 1)
        # Thres_NU_a2[s] = np.mean(Lpred_max_a2/Lpred_mean_a2)
        # stdv_NU_a2[s]  = np.std(Lpred_max_a2/Lpred_mean_a2)
    
      Thres_NU = (Thres_NU_a1+Thres_NU_a2)/2
      stdv_NU  = (stdv_NU_a1 + stdv_NU_a2)/2 

      plt.plot(SNRdb_range, Thres_NU, 'r-o',SNRdb_range, Thres_NU+2*stdv_NU, 'c:o',SNRdb_range, Thres_NU-2*stdv_NU, 'c:o')
      plt.title('No User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.show()
    
    
      #====================================================================================================================================================
      # Estimating threshold for ONE USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        Thres_OU_cls_a1  = np.zeros(Num_classes_OU)
        stdv_OU_cls_a1   = np.zeros(Num_classes_OU)
        Thres_OU_cls_a2  = np.zeros(Num_classes_OU)
        stdv_OU_cls_a2   = np.zeros(Num_classes_OU)
        
        Thres_OU_cls  = np.zeros(Num_classes_OU)
        stdv_OU_cls   = np.zeros(Num_classes_OU)
        n                = num_test_perSNRval_OU * Num_classes_OU
        # ANTENNA 1
        Test_a1       = Test_OU_a1[0 + s * n: (s + 1) * n,:]
        Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
        for cls in range(Num_classes_OU):
          Lpred_cls_a1 = Lpred_a1[0+ cls * num_test_perSNRval_OU : (cls + 1) * num_test_perSNRval_OU,cls]
          Thres_OU_cls_a1[cls] = np.mean(Lpred_cls_a1)
          stdv_OU_cls_a1[cls]  = np.std(Lpred_cls_a1)
        Thres_OU_a1[s]  = np.mean(Thres_OU_cls_a1) 
        stdv_OU_a1[s]   = np.mean(stdv_OU_cls_a1)
    
        # # ========================== PMR ===========================================
        # Thres_OU_a1[s]   = np.mean(Lpred_a1.max(axis = 1)/np.mean(Lpred_a1, axis = 1))
        # stdv_OU_a1[s]    = np.std(Lpred_a1.max(axis = 1)/np.mean(Lpred_a1, axis = 1))
    
        # ANTENNA 2
        Test_a2       = Test_OU_a2[0 + s * n: (s + 1) * n,:]
        Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
        for cls in range(Num_classes_OU):
          Lpred_cls_a2 = Lpred_a2[0+ cls * num_test_perSNRval_OU : (cls + 1) * num_test_perSNRval_OU,cls]
          Thres_OU_cls_a2[cls] = np.mean(Lpred_cls_a2)
          stdv_OU_cls_a2[cls]  = np.std(Lpred_cls_a2)
        Thres_OU_a2[s]  = np.mean(Thres_OU_cls_a2) 
        stdv_OU_a2[s]   = np.mean(stdv_OU_cls_a2)
        
        # # ================= Average outputs from two antennas ========================
        # Lpred      = (Lpred_a1 + Lpred_a2)/2
        # for cls in range(Num_classes_OU):
        #   Lpred_cls = Lpred[0+ cls * num_test_perSNRval_OU : (cls + 1) * num_test_perSNRval_OU,cls]
        #   Thres_OU_cls[cls] = np.mean(Lpred_cls)
        #   stdv_OU_cls[cls]  = np.std(Lpred_cls)
        # Thres_OU[s]  = np.mean(Thres_OU_cls) 
        # stdv_OU[s]   = np.mean(stdv_OU_cls)
        
        # # ========================== PMR ===========================================
        # Thres_OU_a2[s]   = np.mean(Lpred_a2.max(axis = 1)/np.mean(Lpred_a2,axis = 1))
        # stdv_OU_a2[s]   = np.std(Lpred_a2.max(axis = 1)/np.mean(Lpred_a2,axis = 1))
    
      Thres_OU = (Thres_OU_a1+Thres_OU_a2)/2
      stdv_OU  = (stdv_OU_a1 + stdv_OU_a2)/2
    
      plt.plot(SNRdb_range, Thres_OU, 'g-o',SNRdb_range, Thres_OU-2*stdv_OU, 'c:o')
      plt.title('One User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.show()  
    
      #====================================================================================================================================================
      # Estimating threshold for TWO USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        Thres_TU_cls_a1p1  = np.zeros(Num_classes_TU)
        stdv_TU_cls_a1p1   = np.zeros(Num_classes_TU)
        Thres_TU_cls_a1p2  = np.zeros(Num_classes_TU)
        stdv_TU_cls_a1p2   = np.zeros(Num_classes_TU)
        Thres_TU_cls_a2p1  = np.zeros(Num_classes_TU)
        stdv_TU_cls_a2p1   = np.zeros(Num_classes_TU)
        Thres_TU_cls_a2p2  = np.zeros(Num_classes_TU)
        stdv_TU_cls_a2p2   = np.zeros(Num_classes_TU)
        
        Thres_TU_cls_p1  = np.zeros(Num_classes_TU)
        stdv_TU_cls_p1   = np.zeros(Num_classes_TU)
        Thres_TU_cls_p2  = np.zeros(Num_classes_TU)
        stdv_TU_cls_p2   = np.zeros(Num_classes_TU)
        n                = num_test_perSNRval_TU * Num_classes_TU
        # ANTENNA 1
        Test_a1       = Test_TU_a1[0 + s * n: (s + 1) * n,:]
        Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
        for cls in range(Num_classes_TU):
          Label        = Ltest_TU[0+ cls * num_test_perSNRval_TU,:]
          true_ind     = np.where(Label == 1)
          Lpred_cls_a1p1         = Lpred_a1[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][0]]
          Thres_TU_cls_a1p1[cls] = np.mean(Lpred_cls_a1p1)
          stdv_TU_cls_a1p1[cls]  = np.std(Lpred_cls_a1p1)
          Lpred_cls_a1p2         = Lpred_a1[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][1]]
          Thres_TU_cls_a1p2[cls] = np.mean(Lpred_cls_a1p2)
          stdv_TU_cls_a1p2[cls]  = np.std(Lpred_cls_a1p2)
        Thres_TU_a1p1[s]  = np.mean(Thres_TU_cls_a1p1) 
        stdv_TU_a1p1[s]   = np.mean(stdv_TU_cls_a1p1)
        Thres_TU_a1p2[s]  = np.mean(Thres_TU_cls_a1p2) 
        stdv_TU_a1p2[s]   = np.mean(stdv_TU_cls_a1p2)
    
        # # ========================== PMR ===========================================
        # Thres_TU_a1p1[s] = np.mean(Lpred_a1.max(axis = 1)/np.mean(Lpred_a1,axis = 1))
        # stdv_TU_a1p1[s]  = np.std(Lpred_a1.max(axis = 1)/np.mean(Lpred_a1,axis = 1))
      
        # ANTENNA 2
        Test_a2       = Test_TU_a2[0 + s * n: (s + 1) * n,:]
        Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
        for cls in range(Num_classes_TU):
          Label        = Ltest_TU[0+ cls * num_test_perSNRval_TU,:]
          true_ind     = np.where(Label == 1)
          Lpred_cls_a2p1         = Lpred_a2[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][0]]
          Thres_TU_cls_a2p1[cls] = np.mean(Lpred_cls_a2p1)
          stdv_TU_cls_a2p1[cls]  = np.std(Lpred_cls_a2p1)
          Lpred_cls_a2p2         = Lpred_a2[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][1]]
          Thres_TU_cls_a2p2[cls] = np.mean(Lpred_cls_a2p2)
          stdv_TU_cls_a2p2[cls]  = np.std(Lpred_cls_a2p2)
        Thres_TU_a2p1[s]  = np.mean(Thres_TU_cls_a2p1) 
        stdv_TU_a2p1[s]   = np.mean(stdv_TU_cls_a2p1)
        Thres_TU_a2p2[s]  = np.mean(Thres_TU_cls_a2p2) 
        stdv_TU_a2p2[s]   = np.mean(stdv_TU_cls_a2p2)
    
    
        # # ================= Average outputs from two antennas ========================
        # Lpred      = (Lpred_a1 + Lpred_a2)/2
        # for cls in range(Num_classes_TU):
        #   Label        = Ltest_TU[0+ cls * num_test_perSNRval_TU,:]
        #   true_ind     = np.where(Label == 1)
        #   Lpred_cls_p1         = Lpred[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][0]]
        #   Thres_TU_cls_p1[cls] = np.mean(Lpred_cls_p1)
        #   stdv_TU_cls_p1[cls]  = np.std(Lpred_cls_p1)
        #   Lpred_cls_p2         = Lpred[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][1]]
        #   Thres_TU_cls_p2[cls] = np.mean(Lpred_cls_p2)
        #   stdv_TU_cls_p2[cls]  = np.std(Lpred_cls_p2)
        # Thres_TU_p1[s]  = np.mean(Thres_TU_cls_p1) 
        # stdv_TU_p1[s]   = np.mean(stdv_TU_cls_p1)
        # Thres_TU_p2[s]  = np.mean(Thres_TU_cls_p2) 
        # stdv_TU_p2[s]   = np.mean(stdv_TU_cls_p2)
        
        
        # # ========================== PMR ===========================================
        # Thres_TU_a2p1[s] = np.mean(Lpred_a2.max(axis = 1)/np.mean(Lpred_a2,axis = 1))
        # stdv_TU_a2p1[s]  = np.std(Lpred_a2.max(axis = 1)/np.mean(Lpred_a2,axis = 1))
    
      Thres_TU_p1 = (Thres_TU_a1p1+Thres_TU_a2p1)/2
      stdv_TU_p1  = (stdv_TU_a1p1 + stdv_TU_a2p1)/2
      Thres_TU_p2 = (Thres_TU_a1p2+Thres_TU_a2p2)/2
      stdv_TU_p2  = (stdv_TU_a1p2 + stdv_TU_a2p2)/2
      Thres_TU    = (Thres_TU_p1+Thres_TU_p2)/2
      stdv_TU     = (stdv_TU_p1 + stdv_TU_p2)/2
      
      # # ================= Average outputs from two antennas ========================
      # Thres_TU      = (Thres_TU_p1+Thres_TU_p2)/2
      # stdv_TU       = (stdv_TU_p1 + stdv_TU_p2)/2
      
      # # =========================== PMR ============================================
      # Thres_TU      = (Thres_TU_a1p1+Thres_TU_a2p1)/2
      # stdv_TU       = (stdv_TU_a1p1 + stdv_TU_a2p1)/2
    
    
      plt.plot(SNRdb_range, Thres_TU, 'b-o', SNRdb_range, Thres_TU-2*stdv_TU, 'c:o')
      # # =========================== PMR ============================================
      # plt.plot(SNRdb_range, Thres_TU, 'b-o', SNRdb_range, Thres_TU-2*stdv_TU, 'c:o')
      plt.title('Two User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.legend(["User 1", "User 2"])
      plt.show()   
    
      if Channel == 0:
        results_awgn_TOFO['Mean output value (NU)'] = Thres_NU
        results_awgn_TOFO['Mean output value (OU)'] = Thres_OU
        results_awgn_TOFO['Mean output value (TU)'] = Thres_TU
    
      elif Channel == 1:
        results_ray_TOFO['Mean output value (NU)'] = Thres_NU
        results_ray_TOFO['Mean output value (OU)'] = Thres_OU
        results_ray_TOFO['Mean output value (TU)'] = Thres_TU
        
      elif Channel == 2:
        results_epa_TOFO['Mean output value (NU)'] = Thres_NU
        results_epa_TOFO['Mean output value (OU)'] = Thres_OU
        results_epa_TOFO['Mean output value (TU)'] = Thres_TU
    


#%%% Combining inputs from two antennas 

if combine_outputs!=1:
    if Output_analysis:
      if Train_model != 1:
        ZC_TOFO_model = tf.keras.models.load_model(Model_path)
    
      Thres_NU  = np.zeros(Num_SNR_val)
      stdv_NU   = np.zeros(Num_SNR_val)
      Thres_OU  = np.zeros(Num_SNR_val)
      stdv_OU   = np.zeros(Num_SNR_val)
      Thres_TU_p1  = np.zeros(Num_SNR_val)
      stdv_TU_p1   = np.zeros(Num_SNR_val)
      Thres_TU_p2  = np.zeros(Num_SNR_val)
      stdv_TU_p2   = np.zeros(Num_SNR_val)
    
      #====================================================================================================================================================
      # Estimating threshold for NO USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        n             = num_test_perSNRval_NU * Num_classes_NU
        # ANTENNA 1 data
        Test_a1       = Test_NU_a1[0 + s * n: (s + 1) * n,:]
        # ANTENNA 2 data
        Test_a2       = Test_NU_a2[0 + s * n: (s + 1) * n,:]
        # Combined data
        Test_com      = Test_a1 + Test_a2
        Lpred_com     = ZC_TOFO_model.predict(Test_com)
        Lpred_max_com  = Lpred_a1.max(axis = 1)   
        Thres_NU[s] = np.mean(Lpred_max_com)
        stdv_NU[s]  = np.std(Lpred_max_com)
    
      plt.plot(SNRdb_range, Thres_NU, 'r-o',SNRdb_range, Thres_NU+2*stdv_NU, 'c:o',SNRdb_range, Thres_NU-2*stdv_NU, 'c:o')
      plt.title('No User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.show()
    
    
      #====================================================================================================================================================
      # Estimating threshold for ONE USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        Thres_OU_cls_com  = np.zeros(Num_classes_OU)
        stdv_OU_cls_com   = np.zeros(Num_classes_OU)
        n                = num_test_perSNRval_OU * Num_classes_OU
        # ANTENNA 1 data
        Test_a1       = Test_OU_a1[0 + s * n: (s + 1) * n,:]
        # ANTENNA 2 data
        Test_a2       = Test_OU_a2[0 + s * n: (s + 1) * n,:]
        # Combined data
        Test_com      = Test_a1 + Test_a2
        Lpred_com     = ZC_TOFO_model.predict(Test_com)
        for cls in range(Num_classes_OU):
          Lpred_cls_com = Lpred_com[0+ cls * num_test_perSNRval_OU : (cls + 1) * num_test_perSNRval_OU,cls]
          Thres_OU_cls_com[cls] = np.mean(Lpred_cls_com)
          stdv_OU_cls_com[cls]  = np.std(Lpred_cls_com)
        Thres_OU[s]  = np.mean(Thres_OU_cls_com) 
        stdv_OU[s]   = np.mean(stdv_OU_cls_com)
    
      plt.plot(SNRdb_range, Thres_OU, 'g-o',SNRdb_range, Thres_OU-2*stdv_OU, 'c:o')
      plt.title('One User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.show()  
    
      #====================================================================================================================================================
      # Estimating threshold for TWO USER case
      #====================================================================================================================================================
      for s in range(Num_SNR_val):
        Thres_TU_cls_p1  = np.zeros(Num_classes_TU)
        stdv_TU_cls_p1   = np.zeros(Num_classes_TU)
        Thres_TU_cls_p2  = np.zeros(Num_classes_TU)
        stdv_TU_cls_p2   = np.zeros(Num_classes_TU)
        n                = num_test_perSNRval_TU * Num_classes_TU
        # ANTENNA 1 data
        Test_a1       = Test_TU_a1[0 + s * n: (s + 1) * n,:]
        # ANTENNA 2 data
        Test_a2       = Test_TU_a2[0 + s * n: (s + 1) * n,:]
        # Combined data
        Test_com      = Test_a1 + Test_a2
        Lpred_com     = ZC_TOFO_model.predict(Test_com)
        for cls in range(Num_classes_TU):
          Label        = Ltest_TU[0+ cls * num_test_perSNRval_TU,:]
          true_ind     = np.where(Label == 1)
          Lpred_cls_p1         = Lpred_com[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][0]]
          Thres_TU_cls_p1[cls] = np.mean(Lpred_cls_p1)
          stdv_TU_cls_p1[cls]  = np.std(Lpred_cls_p1)
          Lpred_cls_p2         = Lpred_com[0+ cls * num_test_perSNRval_TU : (cls + 1) * num_test_perSNRval_TU,true_ind[0][1]]
          Thres_TU_cls_p2[cls] = np.mean(Lpred_cls_p2)
          stdv_TU_cls_p2[cls]  = np.std(Lpred_cls_p2)
        Thres_TU_p1[s]  = np.mean(Thres_TU_cls_p1) 
        stdv_TU_p1[s]   = np.mean(stdv_TU_cls_p1)
        Thres_TU_p2[s]  = np.mean(Thres_TU_cls_p2) 
        stdv_TU_p2[s]   = np.mean(stdv_TU_cls_p2)
    
      Thres_TU    = (Thres_TU_p1+Thres_TU_p2)/2
      stdv_TU     = (stdv_TU_p1 + stdv_TU_p2)/2
      
      plt.plot(SNRdb_range, Thres_TU, 'b-o', SNRdb_range, Thres_TU-2*stdv_TU, 'c:o')
      plt.title('Two User case')
      plt.xlabel('SNR in dB')
      plt.ylabel('Mean output value')
      plt.legend(["User 1", "User 2"])
      plt.show()   
    
      if Channel == 0:
        results_awgn_TOFO['Mean output value (NU)'] = Thres_NU
        results_awgn_TOFO['Mean output value (OU)'] = Thres_OU
        results_awgn_TOFO['Mean output value (TU)'] = Thres_TU
    
      elif Channel == 1:
        results_ray_TOFO['Mean output value (NU)'] = Thres_NU
        results_ray_TOFO['Mean output value (OU)'] = Thres_OU
        results_ray_TOFO['Mean output value (TU)'] = Thres_TU
        
      elif Channel == 2:
        results_epa_TOFO['Mean output value (NU)'] = Thres_NU
        results_epa_TOFO['Mean output value (OU)'] = Thres_OU
        results_epa_TOFO['Mean output value (TU)'] = Thres_TU



#%% PLOT TRAINING AND VALIDATION LOSS & ACCURACY


if Train_model:
  # Plotting training and validation loss

  Train_loss = history.history['loss']
  Val_loss   = history.history['val_loss']
  plt.plot(range(1,len(Train_loss)+1), Train_loss, 'g', label='Training loss')
  plt.plot(range(1,len(Train_loss)+1), Val_loss, 'b', label='validation loss')
  plt.title('Training and Validation binary crossentropy loss')
  plt.xlabel('Epochs')
  plt.ylabel('Loss')
  plt.legend()
  plt.show()

if Output_analysis == 0:
  results_awgn_TOFO = pd.read_excel(Results_path+"AWGN_output_analysis_TOFO.xlsx")
  results_ray_TOFO  = pd.read_excel(Results_path+"RAYLEIGH_output_analysis_TOFO.xlsx")
  results_epa_TOFO  = pd.read_excel(Results_path+"EPA_output_analysis_TOFO.xlsx")

# Threshold    = np.min(np.array([np.min(results_awgn_TOFO['Mean output value (TU)']),np.min(results_ray_TOFO['Mean output value (TU)']),np.min(results_epa_TOFO['Mean output value (TU)'])]))
Threshold    = np.min(np.array(results_ray_TOFO['Mean output value (TU)']))
binarizer    = Binarizer(threshold = Threshold)

if Train_model !=1:
   ZC_TOFO_model = tf.keras.models.load_model(Model_path)

#====================================================================================================================================================
# Evaluating the model for train and validation data from ONE USER case
#====================================================================================================================================================
print("\n=========== Evaluation results for train ({} samples) and validation ({} samples) data ({} dB)from ONE USER case (0.293 probability) ===========".format(Dtrain_OU.shape[0],Dval_OU.shape[0],Train_snr))
n_train       = Dtrain_OU.shape[0]
n_val         = Dval_OU.shape[0]
# Train data
Lpred_bin_tr     = binarizer.fit_transform(ZC_TOFO_model.predict(Dtrain_OU))
# Lpred = ZC_TOFO_model.predict(Dtrain_OU)
False_alarm_train = 0
Miss_det_train    = 0
success_train     = 0
for i in range(n_train):
  pred = Lpred_bin_tr[i,:]
  true = Ltrain_OU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if not len(pred_ind[0]) > 1:
      if true_ind[0] != pred_ind[0]:
          False_alarm_train += 1
      else:
        success_train +=1
    else:
      False_alarm_train += 1
  else:
    Miss_det_train +=1  
# Validation data
Lpred_bin_val     = binarizer.fit_transform(ZC_TOFO_model.predict(Dval_OU))
False_alarm_val = 0
Miss_det_val    = 0
success_val     = 0
for i in range(n_val):
  pred = Lpred_bin_val[i,:]
  true = Lval_OU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if not len(pred_ind[0]) > 1:
      if true_ind[0] != pred_ind[0]:
          False_alarm_val += 1
      else:
        success_val +=1
    else:
      False_alarm_val += 1
  else:
    Miss_det_val +=1     

print("\n================= Train data =====================\n")    
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((success_train/n_train)*100,success_train,n_train))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((False_alarm_train/n_train)*100,False_alarm_train,n_train))
print("Missdetection         : {:.2f}% ({}/{} samples)".format((Miss_det_train/n_train)*100,Miss_det_train,n_train))
print("\n============== Validation data ===================\n")    
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((success_val/n_val)*100,success_val,n_val))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((False_alarm_val/n_val)*100,False_alarm_val,n_val)) 
print("Missdetection         : {:.2f}% ({}/{} samples)".format((Miss_det_val/n_val)*100,Miss_det_val,n_val))

#====================================================================================================================================================
# Evaluating the model for train and validation data from TWO USER case
#====================================================================================================================================================
print("\n=========== Evaluation results for train ({} samples) and validation ({} samples) data ({} dB)from TWO USER case (0.064 probability) ===========".format(Dtrain_TU.shape[0],Dval_TU.shape[0],Train_snr))
n_train       = Dtrain_TU.shape[0]
n_val         = Dval_TU.shape[0]
# Train data
Lpred_bin_tr     = binarizer.fit_transform(ZC_TOFO_model.predict(Dtrain_TU))
False_alarm_train = 0
Miss_det_train    = 0
success_train     = 0
suc_FU_train      = 0
suc_SU_train      = 0
for i in range(n_train):
  pred = Lpred_bin_tr[i,:]
  true = Ltrain_TU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if len(pred_ind[0]) == 1:
      Miss_det_train +=1
      if pred_ind[0][0] == true_ind[0][0]:
        suc_FU_train +=1
      elif pred_ind[0][0] == true_ind[0][1]:
        suc_SU_train +=1
    elif (len(pred_ind[0]) == 2):
      if not (np.array_equal(true_ind[0],pred_ind[0])):
          False_alarm_train += 1
      else:
          success_train +=1
    else:
      False_alarm_train += 1
  else:
    Miss_det_train +=1  
# Validation data
Lpred_bin_val     = binarizer.fit_transform(ZC_TOFO_model.predict(Dval_TU))
False_alarm_val = 0
Miss_det_val    = 0
success_val     = 0
suc_FU_val      = 0
suc_SU_val      = 0
for i in range(n_val):
  pred = Lpred_bin_val[i,:]
  true = Lval_TU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if len(pred_ind[0]) == 1:
      Miss_det_val +=1
      if pred_ind[0][0] == true_ind[0][0]:
        suc_FU_val +=1
      elif pred_ind[0][0] == true_ind[0][1]:
        suc_SU_val +=1
    elif (len(pred_ind[0]) == 2):
      if not (np.array_equal(true_ind[0],pred_ind[0])):
          False_alarm_val += 1
      else:
          success_val +=1
    else:
      False_alarm_val += 1
  else:
    Miss_det_val +=1 

print("\n================= Train data =====================\n")    
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((success_train/n_train)*100,success_train,n_train))
print("Accuracy in detection of first user  : {:.2f}% ({}/{} samples)\n".format(((success_train + suc_FU_train)/n_train)*100,success_train + suc_FU_train,n_train)) 
print("Accuracy in detection of second user : {:.2f}% ({}/{} samples)\n".format(((success_train + suc_SU_train)/n_train)*100,success_train + suc_SU_train,n_train))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((False_alarm_train/n_train)*100,False_alarm_train,n_train))
print("Missdetection         : {:.2f}% ({}/{} samples)".format((Miss_det_train/n_train)*100,Miss_det_train,n_train))
print("\n============== Validation data ===================\n")    
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((success_val/n_val)*100,success_val,n_val))
print("Accuracy in detection of first user  : {:.2f}% ({}/{} samples)\n".format(((success_val + suc_FU_val)/n_val)*100,success_val + suc_FU_val,n_val)) 
print("Accuracy in detection of second user : {:.2f}% ({}/{} samples)\n".format(((success_val + suc_SU_val)/n_val)*100,success_val + suc_SU_val,n_val))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((False_alarm_val/n_val)*100,False_alarm_val,n_val)) 
print("Missdetection         : {:.2f}% ({}/{} samples)".format((Miss_det_val/n_val)*100,Miss_det_val,n_val))



#%% EVALUATING TRAINED/SAVED MODEL ON TEST DATA


if Output_analysis == 0:
  results_awgn_TOFO = pd.read_excel(Results_path+"AWGN_output_analysis_TOFO.xlsx")
  results_ray_TOFO  = pd.read_excel(Results_path+"RAYLEIGH_output_analysis_TOFO.xlsx")
  results_epa_TOFO  = pd.read_excel(Results_path+"EPA_output_analysis_TOFO.xlsx")

# if Accuracy_analysis == 1:
#   accuracy_NU_TOFO  = pd.read_excel(Results_path+"NU_Test_accuracy_analysis_TOFO.xlsx")
#   accuracy_OU_TOFO  = pd.read_excel(Results_path+"OU_Test_accuracy_analysis_TOFO.xlsx")
#   accuracy_TU_TOFO  = pd.read_excel(Results_path+"TU_Test_accuracy_analysis_TOFO.xlsx")  

# Threshold    = np.min(np.array([np.min(results_awgn_TOFO['Mean output value (TU)']),np.min(results_ray_TOFO['Mean output value (TU)']),np.min(results_epa_TOFO['Mean output value (TU)'])]))
Threshold    = np.min(results_ray_TOFO['Mean output value (TU)'])
binarizer    = Binarizer(threshold = Threshold)
print("================ THRESHOLD : {} ====================\n".format(Threshold))

if Train_model != 1:
  ZC_TOFO_model = tf.keras.models.load_model(Model_path)

Test_acc_a1 = list()
Test_acc    = list()
Test_fpr    = list()
Success_NUL  = list()
False_alarm_NUL_1 = list()
False_alarm_NUL_2 = list()
#====================================================================================================================================================
# Evaluating the model for test data from NO USER case
#====================================================================================================================================================
Num_test_NU = Test_NU_a1.shape[0]
print("=========== Evaluation results for test data ({} samples) from NO USER case (0.634 probability) ===========".format(Num_test_NU))
for s in range(Num_SNR_val):
  n             = num_test_perSNRval_NU * Num_classes_NU
  Labels        = Ltest_NU[0 + s * n: (s + 1) * n,:]
  # ANTENNA 1
  Test_a1       = Test_NU_a1[0 + s * n: (s + 1) * n,:]
  Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
  Lpred_bin_a1  = binarizer.fit_transform(Lpred_a1)
  # ANTENNA 2
  Test_a2       = Test_NU_a2[0 + s * n: (s + 1) * n,:]
  Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
  Lpred_bin_a2  = binarizer.fit_transform(Lpred_a2)
  # COMBINED OUTPUT 
  Lpred_bin     = np.logical_or(Lpred_bin_a1,Lpred_bin_a2).astype(float) 
  # Lpred_bin = binarizer.fit_transform((Lpred_a1 + Lpred_a2)/2)
  
  False_alarm_a1 = 0
  False_alarm = 0
  False_alarm_1 = 0
  False_alarm_2 = 0
  for i in range(n):
    pred_a1 = Lpred_bin_a1[i,:]
    pred = Lpred_bin[i,:]
    true = Labels[i,:]
    if not (np.array_equal(pred_a1,true)):
      False_alarm_a1 +=1
    if not (np.array_equal(pred,true)):
      False_alarm +=1  
      pred_ind = np.where(pred == 1)
      if len(pred_ind[0]) == 1:
        False_alarm_1 += 1
      elif len(pred_ind[0]) == 2: 
        False_alarm_2 += 1

  success    = n - False_alarm
  success_a1 = n - False_alarm_a1   
  Success_NUL.append(success) 
  False_alarm_NUL_1.append(False_alarm_1)
  False_alarm_NUL_2.append(False_alarm_2)
  Test_acc.append((success/n)*100) 
  Test_fpr.append((False_alarm/n)*100)
  Test_acc_a1.append((success_a1/n)*100)   

  print("\n================= {} dB =====================".format(SNRdb_range[s]))    
  print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((success/n)*100,success,n))
  print("False positive rate   : {:.2f}% ({}/{} samples)".format((False_alarm/n)*100,False_alarm,n))

if Accuracy_analysis == 1:
  if Channel == 0:
    accuracy_NU_TOFO["AWGN (Acc)"] = Test_acc
    accuracy_NU_TOFO["AWGN (FPR)"] = Test_fpr
  elif Channel == 1:
    accuracy_NU_TOFO["RAYLEIGH (Acc)"] = Test_acc
    accuracy_NU_TOFO["RAYLEIGH (FPR)"] = Test_fpr
  elif Channel == 2:
    accuracy_NU_TOFO["EPA (Acc)"] = Test_acc
    accuracy_NU_TOFO["EPA (FPR)"] = Test_fpr

if Extra_results_analysis: 
  if Channel == 0:
    extra_results_awgn_TOFO["NU (FA_1)"] = False_alarm_NUL_1
    extra_results_awgn_TOFO["NU (FA_2)"] = False_alarm_NUL_2
  elif Channel == 1:
    extra_results_ray_TOFO["NU (FA_1)"] = False_alarm_NUL_1
    extra_results_ray_TOFO["NU (FA_2)"] = False_alarm_NUL_2
  elif Channel == 2:
    extra_results_epa_TOFO["NU (FA_1)"] = False_alarm_NUL_1
    extra_results_epa_TOFO["NU (FA_2)"] = False_alarm_NUL_2  

# ANTENNA 1
Lpred_NU_a1      = ZC_TOFO_model.predict(Test_NU_a1)
Lpred_NU_bin_a1  = binarizer.fit_transform(Lpred_NU_a1)
# ANTENNA 2
Lpred_NU_a2      = ZC_TOFO_model.predict(Test_NU_a2)
Lpred_NU_bin_a2  = binarizer.fit_transform(Lpred_NU_a2)
# COMBINED OUTPUT
Lpred_NU_bin     = np.logical_or(Lpred_NU_bin_a1,Lpred_NU_bin_a2).astype(float)
# Lpred_NU_bin = binarizer.fit_transform((Lpred_NU_a1 + Lpred_NU_a2)/2)

Tot_false_alarm_NU   = 0
Tot_false_alarm_NU_1 = 0
Tot_false_alarm_NU_2 = 0
for i in range(Num_test_NU):
  pred = Lpred_NU_bin[i,:]
  true = Ltest_NU[i,:]
  if not (np.array_equal(pred,true)):
    Tot_false_alarm_NU +=1 
    pred_ind = np.where(pred == 1)
    if len(pred_ind[0]) == 1:
      Tot_false_alarm_NU_1 += 1
    elif len(pred_ind[0]) == 2: 
      Tot_false_alarm_NU_2 += 1

Tot_success_NU = Num_test_NU - Tot_false_alarm_NU

print("\n================= Overall =====================")     
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((Tot_success_NU/Num_test_NU)*100,Tot_success_NU,Num_test_NU))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((Tot_false_alarm_NU/Num_test_NU)*100,Tot_false_alarm_NU,Num_test_NU))

plt.plot(SNRdb_range, Test_acc, 'r-o',SNRdb_range, Test_acc_a1,'k:*')
plt.title('Test accuracy for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('Accuracy')
plt.legend(["Two rx antenna","One rx antenna"])
plt.show()  




Test_acc_a1  = list()
Test_acc     = list()
Test_fpr     = list()
Success_OUL  = list()
False_alarm_OUL_1 = list()
False_alarm_OUL_2 = list()
Miss_det_OUL    = list()

#====================================================================================================================================================
# Evaluating the model for test data from ONE USER case
#====================================================================================================================================================
Num_test_OU = Test_OU_a1.shape[0]
print("\n=========== Evaluation results for test data ({} samples) from ONE USER case (0.293 probability) ===========".format(Num_test_OU))
for s in range(Num_SNR_val):
  n          = num_test_perSNRval_OU * Num_classes_OU
  Labels     = Ltest_OU[0 + s * n : (s + 1) * n,:]

  # ANTENNA 1
  Test_a1       = Test_OU_a1[0 + s * n: (s + 1) * n,:]
  Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
  Lpred_bin_a1  = binarizer.fit_transform(Lpred_a1)
  # ANTENNA 2
  Test_a2       = Test_OU_a2[0 + s * n: (s + 1) * n,:]
  Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
  Lpred_bin_a2  = binarizer.fit_transform(Lpred_a2)
  # COMBINED OUTPUT 
  Lpred_bin     = np.logical_or(Lpred_bin_a1,Lpred_bin_a2).astype(float)          # For TOFO
  # Lpred_bin = binarizer.fit_transform((Lpred_a1 + Lpred_a2)/2)
  
  Miss_det_a1    = 0
  False_alarm_a1 = 0
  success_a1     = 0
  Miss_det       = 0
  False_alarm_1  = 0
  False_alarm_2  = 0
  success        = 0
  
  for i in range(n):
    pred_a1 = Lpred_bin_a1[i,:]
    pred = Lpred_bin[i,:]
    true = Labels[i,:]
    # One antenna 
    if 1 in pred_a1:
      pred_ind = np.where(pred_a1 == 1)
      true_ind = np.where(true == 1)
      if not len(pred_ind[0]) > 1:
        if true_ind[0] != pred_ind[0]:
           False_alarm_a1 += 1
        else:
          success_a1 +=1
      else:
        False_alarm_a1 += 1
    else:
      Miss_det_a1 +=1

    # Two antenna  
    if 1 in pred:
      pred_ind = np.where(pred == 1)
      true_ind = np.where(true == 1)
      if not len(pred_ind[0]) > 1:
        if true_ind[0] != pred_ind[0]:
           False_alarm_2 += 1
        else:
          success +=1
      else:
        False_alarm_1 += 1
    else:
      Miss_det +=1 

  False_alarm = False_alarm_1 + False_alarm_2

  Success_OUL.append(success)
  False_alarm_OUL_1.append(False_alarm_1)
  False_alarm_OUL_2.append(False_alarm_2)
  Miss_det_OUL.append(Miss_det)
  Test_acc.append((success/n)*100)
  Test_fpr.append((False_alarm/n)*100)
  Test_acc_a1.append((success_a1/n)*100)

  print("\n================= {} dB =====================".format(SNRdb_range[s]))   
  print("Accuracy             : {:.2f}% ({}/{} samples)\n".format((success/n)*100,success,n))
  print("False positive rate  : {:.2f}% ({}/{} samples)\n".format((False_alarm/n)*100,False_alarm,n))
  print("Missdetection        : {:.2f}% ({}/{} samples)".format((Miss_det/n)*100,Miss_det,n))

if Accuracy_analysis == 1:     
  if Channel == 0:
    accuracy_OU_TOFO["AWGN (Acc)"] = Test_acc
    accuracy_OU_TOFO["AWGN (FPR)"] = Test_fpr
  elif Channel == 1:
    accuracy_OU_TOFO["RAYLEIGH (Acc)"] = Test_acc
    accuracy_OU_TOFO["RAYLEIGH (FPR)"] = Test_fpr
  elif Channel == 2:
    accuracy_OU_TOFO["EPA (Acc)"] = Test_acc
    accuracy_OU_TOFO["EPA (FPR)"] = Test_fpr

if Extra_results_analysis: 
  if Channel == 0:
    extra_results_awgn_TOFO["OU (FA_1)"] = False_alarm_OUL_1
    extra_results_awgn_TOFO["OU (FA_2)"] = False_alarm_OUL_2
    extra_results_awgn_TOFO["OU (MD)"] = Miss_det_OUL
  elif Channel == 1:
    extra_results_ray_TOFO["OU (FA_1)"] = False_alarm_OUL_1
    extra_results_ray_TOFO["OU (FA_2)"] = False_alarm_OUL_2
    extra_results_ray_TOFO["OU (MD)"] = Miss_det_OUL
  elif Channel == 2:
    extra_results_epa_TOFO["OU (FA_1)"] = False_alarm_OUL_1
    extra_results_epa_TOFO["OU (FA_2)"] = False_alarm_OUL_2    
    extra_results_epa_TOFO["OU (MD)"] = Miss_det_OUL  

# ANTENNA 1
Lpred_OU_a1      = ZC_TOFO_model.predict(Test_OU_a1)
Lpred_OU_bin_a1  = binarizer.fit_transform(Lpred_OU_a1)
# ANTENNA 2
Lpred_OU_a2      = ZC_TOFO_model.predict(Test_OU_a2)
Lpred_OU_bin_a2  = binarizer.fit_transform(Lpred_OU_a2)
# COMBINED OUTPUT
Lpred_OU_bin     = np.logical_or(Lpred_OU_bin_a1,Lpred_OU_bin_a2).astype(float)
# Lpred_OU_bin = binarizer.fit_transform((Lpred_OU_a1 + Lpred_OU_a2)/2)

Tot_success_OU  = 0
Tot_false_alarm_OU   = 0
Tot_false_alarm_OU_1 = 0
Tot_false_alarm_OU_2 = 0
Tot_miss_det    = 0

for i in range(Num_test_OU):
  pred = Lpred_OU_bin[i,:]
  true = Ltest_OU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if not len(pred_ind[0]) > 1:
      if true_ind[0] != pred_ind[0]:
          Tot_false_alarm_OU_1 += 1
      else:
        Tot_success_OU += 1
    else:
      Tot_false_alarm_OU_2 += 1
  else:
    Tot_miss_det += 1  

Tot_false_alarm_OU = Tot_false_alarm_OU_1 + Tot_false_alarm_OU_2

print("\n================= Overall =====================")     
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((Tot_success_OU/Num_test_OU)*100,Tot_success_OU,Num_test_OU))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((Tot_false_alarm_OU/Num_test_OU)*100,Tot_false_alarm_OU,Num_test_OU))
print("Missdetection         : {:.2f}% ({}/{} samples)\n".format((Tot_miss_det/Num_test_OU)*100,Tot_miss_det,Num_test_OU))

plt.plot(SNRdb_range, Test_acc, 'g-o',SNRdb_range, Test_acc_a1, 'k:*')
plt.title('Data samples with TOFO')
plt.xlabel('SNR in dB')
plt.ylabel('Accuracy')
plt.legend(["Two rx antenna","One rx antenna"])
plt.show()




Test_acc_a1  = list()
Test_acc     = list()
Test_acc_FU  = list()
Test_acc_SU  = list()
Test_fpr     = list()
Success_TUL  = list()
Success_FUL  = list()
Success_SUL  = list()
False_alarm_TUL_1 = list()
False_alarm_TUL_2 = list()
False_alarm_TUL_3 = list()
Miss_det_TUL_1  = list()
Miss_det_TUL_2  = list()
#====================================================================================================================================================
# Evaluating the model for test data from TWO USER case
#====================================================================================================================================================
Num_test_TU = Test_TU_a1.shape[0]
print("\n=========== Evaluation results for test data ({} samples) from TWO USER case (0.064 probability) ===========".format(Num_test_TU))
for s in range(Num_SNR_val):
  n          = num_test_perSNRval_TU * Num_classes_TU
  Labels     = Ltest_TU[0 + s * n : (s + 1) * n,:]
  # ANTENNA 1
  Test_a1       = Test_TU_a1[0 + s * n: (s + 1) * n,:]
  Lpred_a1      = ZC_TOFO_model.predict(Test_a1)
  Lpred_bin_a1  = binarizer.fit_transform(Lpred_a1)
  # ANTENNA 2
  Test_a2       = Test_TU_a2[0 + s * n: (s + 1) * n,:]
  Lpred_a2      = ZC_TOFO_model.predict(Test_a2)
  Lpred_bin_a2  = binarizer.fit_transform(Lpred_a2)
  # COMBINED OUTPUT 
  Lpred_bin     = np.logical_or(Lpred_bin_a1,Lpred_bin_a2).astype(float) 
  # Lpred_bin = binarizer.fit_transform((Lpred_a1 + Lpred_a2)/2)
  
  Miss_det_a1    = 0
  False_alarm_a1 = 0
  success_a1     = 0
  Miss_det_1    = 0
  Miss_det_2    = 0
  False_alarm_1 = 0 # under missdetection case when predicted sequence is not any of the two sequence
  False_alarm_2 = 0 # when predicted two sequences are not matching true sequences
  False_alarm_3 = 0 # when three sequences are predicted
  success     = 0
  suc_FU      = 0
  suc_SU      = 0     
  for i in range(n):
    pred_a1 = Lpred_bin_a1[i,:]
    pred = Lpred_bin[i,:]
    true = Labels[i,:]
    if 1 in pred_a1:
      pred_ind = np.where(pred_a1 == 1)
      true_ind = np.where(true == 1)
      if len(pred_ind[0]) == 1:
        Miss_det_a1 +=1
      elif (len(pred_ind[0]) == 2):
        if not (np.array_equal(true_ind[0],pred_ind[0])):
           False_alarm_a1 += 1
        else:
           success_a1 +=1
      else:
        False_alarm_a1 += 1
    else:
      Miss_det_a1 +=1
    if 1 in pred:
      pred_ind = np.where(pred == 1)
      true_ind = np.where(true == 1)
      if len(pred_ind[0]) == 1:
        if pred_ind[0][0] == true_ind[0][0]:
          suc_FU += 1
          Miss_det_1 +=1
        elif pred_ind[0][0] == true_ind[0][1]:
          suc_SU += 1
          Miss_det_1 +=1
        else:
          False_alarm_1  += 1
      elif (len(pred_ind[0]) == 2):
        if not (np.array_equal(true_ind[0],pred_ind[0])):
           False_alarm_2  += 1
        else:
           success +=1
      else:
        False_alarm_3 += 1
    else:
      Miss_det_2 +=1
  False_alarm =  False_alarm_1 + False_alarm_2 + False_alarm_3  
  Miss_det    =  Miss_det_1 + Miss_det_2
  
  False_alarm_TUL_1.append(False_alarm_1)
  False_alarm_TUL_2.append(False_alarm_2)
  False_alarm_TUL_3.append(False_alarm_3)
  Miss_det_TUL_1.append(Miss_det_1)
  Miss_det_TUL_2.append(Miss_det_2)
  Success_TUL.append(success)
  Success_FUL.append(suc_FU)
  Success_SUL.append(suc_SU)
  Test_acc.append((success/n)*100)  
  Test_acc_FU.append(((success + suc_FU)/n)*100)
  Test_acc_SU.append(((success + suc_SU)/n)*100)
  Test_fpr.append((False_alarm/n)*100)
  Test_acc_a1.append((success_a1/n)*100)  
  print("\n================= {} dB =====================".format(SNRdb_range[s])) 
  print("Accuracy in detection of first user  : {:.2f}% ({}/{} samples)\n".format(((success + suc_FU)/n)*100,success + suc_FU,n)) 
  print("Accuracy in detection of second user : {:.2f}% ({}/{} samples)\n".format(((success + suc_SU)/n)*100,success + suc_SU,n))   
  print("Accuracy             : {:.2f}% ({}/{} samples)\n".format((success/n)*100,success,n))
  print("False positive rate  : {:.2f}% ({}/{} samples)\n".format((False_alarm/n)*100,False_alarm,n))
  print("Missdetection        : {:.2f}% ({}/{} samples)".format((Miss_det/n)*100,Miss_det,n))   

if Accuracy_analysis == 1:
  if Channel == 0:
    accuracy_TU_TOFO["AWGN (Acc)"] = Test_acc
    accuracy_TU_TOFO["AWGN (Acc_FU)"] = Test_acc_FU
    accuracy_TU_TOFO["AWGN (Acc_SU)"] = Test_acc_SU
    accuracy_TU_TOFO["AWGN (FPR)"] = Test_fpr

  elif Channel == 1:
    accuracy_TU_TOFO["RAYLEIGH (Acc)"] = Test_acc
    accuracy_TU_TOFO["RAYLEIGH (Acc_FU)"] = Test_acc_FU
    accuracy_TU_TOFO["RAYLEIGH (Acc_SU)"] = Test_acc_SU
    accuracy_TU_TOFO["RAYLEIGH (FPR)"] = Test_fpr
  elif Channel == 2:
    accuracy_TU_TOFO["EPA (Acc)"] = Test_acc
    accuracy_TU_TOFO["EPA (Acc_FU)"] = Test_acc_FU
    accuracy_TU_TOFO["EPA (Acc_SU)"] = Test_acc_SU
    accuracy_TU_TOFO["EPA (FPR)"] = Test_fpr

if Extra_results_analysis: 
  if Channel == 0:
    extra_results_awgn_TOFO["TU (FA_1)"] = False_alarm_TUL_1
    extra_results_awgn_TOFO["TU (FA_2)"] = False_alarm_TUL_2
    extra_results_awgn_TOFO["TU (FA_3)"] = False_alarm_TUL_3
    extra_results_awgn_TOFO["TU (MD_1)"] = Miss_det_TUL_1
    extra_results_awgn_TOFO["TU (MD_2)"] = Miss_det_TUL_2
  elif Channel == 1:
    extra_results_ray_TOFO["TU (FA_1)"] = False_alarm_TUL_1
    extra_results_ray_TOFO["TU (FA_2)"] = False_alarm_TUL_2
    extra_results_ray_TOFO["TU (FA_3)"] = False_alarm_TUL_3
    extra_results_ray_TOFO["TU (MD_1)"] = Miss_det_TUL_1
    extra_results_ray_TOFO["TU (MD_2)"] = Miss_det_TUL_2
  elif Channel == 2:
    extra_results_epa_TOFO["TU (FA_1)"] = False_alarm_TUL_1
    extra_results_epa_TOFO["TU (FA_2)"] = False_alarm_TUL_2   
    extra_results_epa_TOFO["TU (FA_3)"] = False_alarm_TUL_3 
    extra_results_epa_TOFO["TU (MD_1)"] = Miss_det_TUL_1  
    extra_results_epa_TOFO["TU (MD_2)"] = Miss_det_TUL_2  


# ANTENNA 1
Lpred_TU_a1      = ZC_TOFO_model.predict(Test_TU_a1)
Lpred_TU_bin_a1  = binarizer.fit_transform(Lpred_TU_a1)
# ANTENNA 2
Lpred_TU_a2      = ZC_TOFO_model.predict(Test_TU_a2)
Lpred_TU_bin_a2  = binarizer.fit_transform(Lpred_TU_a2)
# COMBINED OUTPUT
Lpred_TU_bin     = np.logical_or(Lpred_TU_bin_a1,Lpred_TU_bin_a2).astype(float)
# Lpred_TU_bin = binarizer.fit_transform((Lpred_TU_a1 + Lpred_TU_a2)/2)


Tot_success_TU   = 0
Tot_false_alarm_TU_1  = 0
Tot_false_alarm_TU_2  = 0
Tot_false_alarm_TU_3  = 0
Tot_miss_det_TU_1  = 0
Tot_miss_det_TU_2  = 0
suc_FU      = 0
suc_SU      = 0
for i in range(Num_test_TU):
  pred = Lpred_TU_bin[i,:]
  true = Ltest_TU[i,:]
  if 1 in pred:
    pred_ind = np.where(pred == 1)
    true_ind = np.where(true == 1)
    if len(pred_ind[0]) == 1:
      if pred_ind[0][0] == true_ind[0][0]:
        suc_FU +=1
        Tot_miss_det_TU_1 += 1
      elif pred_ind[0][0] == true_ind[0][1]:
        suc_SU +=1
        Tot_miss_det_TU_1 += 1
      else:
        Tot_false_alarm_TU_1 += 1
    elif (len(pred_ind[0]) == 2):
      if not (np.array_equal(true_ind[0],pred_ind[0])):
          Tot_false_alarm_TU_2 += 1
      else:
          Tot_success_TU +=1
    else:
      Tot_false_alarm_TU_3 += 1
  else:
    Tot_miss_det_TU_2 +=1

Tot_false_alarm_TU = Tot_false_alarm_TU_1 + Tot_false_alarm_TU_2 + Tot_false_alarm_TU_3    
Tot_miss_det_TU    = Tot_miss_det_TU_1 + Tot_miss_det_TU_2

print("\n================= Overall =====================")  
print("Accuracy in detection of first user  : {:.2f}% ({}/{} samples)\n".format(((Tot_success_TU + suc_FU)/Num_test_TU)*100,Tot_success_TU + suc_FU,Num_test_TU)) 
print("Accuracy in detection of second user : {:.2f}% ({}/{} samples)\n".format(((Tot_success_TU + suc_SU)/Num_test_TU)*100,Tot_success_TU + suc_SU,Num_test_TU))    
print("Accuracy              : {:.2f}% ({}/{} samples)\n".format((Tot_success_TU/Num_test_TU)*100,Tot_success_TU,Num_test_TU))
print("False positive rate   : {:.2f}% ({}/{} samples)\n".format((Tot_false_alarm_TU/Num_test_TU)*100,Tot_false_alarm_TU,Num_test_TU))
print("Missdetection         : {:.2f}% ({}/{} samples)\n".format((Tot_miss_det_TU/Num_test_TU)*100,Tot_miss_det_TU,Num_test_TU))

plt.plot(SNRdb_range, Test_acc, 'b-o',SNRdb_range, Test_acc_a1, 'k:*')
plt.title('Test accuracy for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('Accuracy')
plt.legend(["Two rx antenna","One rx antenna"])
plt.show()


#%% OVERALL RESULT ANALYSIS

data_per_snr_NU = num_test_perSNRval_NU * Num_classes_NU
data_per_snr_OU = num_test_perSNRval_OU * Num_classes_OU
data_per_snr_TU = num_test_perSNRval_TU * Num_classes_TU

# P(k users picking same slot) = M^C_k * (1/Num_slots)^k * (1- 1/Num_slots)^(M-k)
M         = 18 # average number of users
Num_slots = 40
def prob (k):
  p = scipy.special.comb(M,k)* (1/Num_slots)**k * (1- (1/Num_slots))**(M-k)
  return p

p_NU = prob(0)
p_OU = prob(1)
p_TU = prob(2)
tot_prob = p_NU + p_OU + p_TU
print("Probability of 0/1/2 users choosing same slot : {}\n".format(tot_prob))

SUC_NU = np.array(Success_NUL)/data_per_snr_NU
SUC_OU = np.array(Success_OUL)/data_per_snr_OU
SUC_TU = np.array(Success_TUL)/data_per_snr_TU

FA_NU = (np.array(False_alarm_NUL_1) + np.array(False_alarm_NUL_2))/data_per_snr_NU
FA_OU = (np.array(False_alarm_OUL_1) + np.array(False_alarm_OUL_2))/data_per_snr_OU
FA_TU = (np.array(False_alarm_TUL_1) + np.array(False_alarm_TUL_2) + np.array(False_alarm_TUL_3))/data_per_snr_TU

Success_OU           = np.array(Success_OUL)/ data_per_snr_OU
Success_TU           = (2*np.array(Success_TUL) + np.array(Success_FUL) + np.array(Success_SUL))/ (2*data_per_snr_TU)
False_alarm_overall  = p_NU * np.array(FA_NU) + p_OU * np.array(FA_OU) + p_TU * np.array(FA_TU)
Accuracy_overall     = p_NU * np.array(SUC_NU) + p_OU * np.array(SUC_OU) + p_TU * np.array(SUC_TU)
Success_overall      = (p_OU * Success_OU + p_TU * Success_TU)/(p_OU + p_TU)

if Overall_accuracy_analysis:
  if Channel == 0: 
    accuracy_overall_TOFO["AWGN (Overall ACC)"] = Accuracy_overall
    accuracy_overall_TOFO["AWGN (Overall FPR)"] = False_alarm_overall
  if Channel == 1: 
    accuracy_overall_TOFO["RAYLEIGH (Overall ACC)"] = Accuracy_overall
    accuracy_overall_TOFO["RAYLEIGH (Overall FPR)"] = False_alarm_overall
  if Channel == 2: 
    accuracy_overall_TOFO["EPA (Overall ACC)"] = Accuracy_overall
    accuracy_overall_TOFO["EPA (Overall FPR)"] = False_alarm_overall    

plt.plot(SNRdb_range, Success_overall*100, 'g-o')
plt.title('Overall detection success for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('Success (%)')
plt.show()

plt.plot(SNRdb_range, Accuracy_overall*100, 'b-o')
plt.title('Overall test accuracy for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('Accuracy (%)')
plt.show()

plt.plot(SNRdb_range, FA_NU*100, 'c-o')
plt.title('false alarm (No user case) for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('False alarm (%)')
plt.show()

plt.plot(SNRdb_range, False_alarm_overall*100, 'r-o')
plt.title('Overall false alarm for different SNR values')
plt.xlabel('SNR in dB')
plt.ylabel('False alarm (%)')
plt.show()



#%% SAVING THE MODEL AND RESULTS 

# Saving the model 
if Save_model:
  tf.keras.models.save_model(ZC_TOFO_model,Model_path,overwrite = False)

# Saving results
if Save_results:
  results_awgn_TOFO.to_excel(Results_path+"AWGN_output_analysis_TOFO.xlsx") 
  results_ray_TOFO.to_excel(Results_path+"RAYLEIGH_output_analysis_TOFO.xlsx")
  results_epa_TOFO.to_excel(Results_path+"EPA_output_analysis_TOFO.xlsx")

if Save_accuracy:  
  accuracy_NU_TOFO.to_excel(Results_path+"NU_Test_accuracy_analysis_TOFO.xlsx") 
  accuracy_OU_TOFO.to_excel(Results_path+"OU_Test_accuracy_analysis_TOFO.xlsx")
  accuracy_TU_TOFO.to_excel(Results_path+"TU_Test_accuracy_analysis_TOFO.xlsx")

if Save_extra_results:
  extra_results_awgn_TOFO.to_excel(Results_path+"AWGN_extra_results_TOFO.xlsx") 
  extra_results_ray_TOFO.to_excel(Results_path+"RAYLEIGH_extra_results_TOFO.xlsx")
  extra_results_epa_TOFO.to_excel(Results_path+"EPA_extra_results_TOFO.xlsx") 

if Save_accuracy_overall:
  accuracy_overall_TOFO.to_excel(Results_path+"Overall_Test_accuracy_analysis_TOFO.xlsx")


